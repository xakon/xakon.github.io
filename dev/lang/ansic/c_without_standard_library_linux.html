<!DOCTYPE html><head><meta charset="UTF-8" /><title>Franc[e]sco's Gopherspace: /programming/c_without_standard_library_linux.txt</title><style>body{font-family:monospace;white-space:pre;color:#afbccc;background-color:#191c1f}a:link,a:visited,a:active,a:hover{color:#bcaeda;text-decoration:none}a:visited{color:#8d849f}</style></head><body>Hello there! You are currently visiting gopherspace through a<br />proxy. To learn more about gopher and how to browse it, read <a href="http://weeb.ddns.net/1/gopher">this</a>.<br />______________________________________________________________________<br /><br />###################################################################<br />          Writing C software without the standard library<br />                           Linux Edition<br />###################################################################<br />There are many tutorials on the web that explain how to build a<br />simple hello world in C without the libc on AMD64, but most of them<br />stop there.<br /><br />I will provide a more complete explanation that will allow you to<br />build yourself a little framework to write more complex programs.<br />The code will support both AMD64 and i386.<br /><br />Major credits to http://betteros.org/ which got me into researching<br />libc-free programming.<br /><br />Why would you want to avoid libc?<br />- Your code will have no dependencies other than the compiler.<br />- Not including the massive header files and not linking the<br />  standard library makes compilation faster. It will be nearly<br />  instantaneous even for thousands of lines of code.<br />- Executables are incredibly small (the http mirror server for my<br />  gopherspace is powered by a 10kb executable).<br />- Easy to optimize for embedded computers that have very limited<br />  resources.<br />- Easy to port to other architectures as long as they are<br />  documented, without having to worry whether the libs you use<br />  support it or not.<br />- Above all, it exposes the inner workings of the OS, architecture<br />  and libc, which teaches you a lot and makes you more aware of<br />  what you're doing even when using high level libraries.<br />- It's a fun challenge!<br /><br />I might not be an expert yet, but I will share my methods with you.<br /><br />For now this guide is linux-only, but I will be writing a windows<br />version when I feel like firing up a virtual machine.<br /><br />###################################################################<br />                         Basic AMD64 Setup<br />###################################################################<br />When we learn C, we are taught that main is the first function<br />called in a C program. In reality, main is simply a convention of<br />the standard library.<br /><br />Let's write a simple hello world and debug it.<br />We will compile with debug information (flag -g) as well as no<br />optimization (-O0) to be able to see as much as possible in the<br />debugger.<br />-------------------------------------------------------------------<br />$ cat > hello.c &lt;&lt; "EOF"<br />#include &lt;stdio.h><br /><br />int main(int argc, char* argv[])<br />{<br />    printf("hello\n");<br /><br />    return 0;<br />}<br />EOF<br /><br />$ gcc -O0 -g hello.c<br />$ ./a.out<br />hello<br /><br />$ gdb a.out<br />(gdb) break main<br />(gdb) run<br />(gdb) backtrace<br />#0  main (argc=1, argv=0x7fffffffd7f8) at hello.c:6<br />-------------------------------------------------------------------<br /><br />Hmm... seems like gdb is hiding stuff from us. Let's tell it that<br />we actually care about seeing libc functions:<br />-------------------------------------------------------------------<br />(gdb) set backtrace past-main on<br />(gdb) set backtrace past-entry on<br />(gdb) bt<br />#0  main (argc=1, argv=0x7fffffffd7f8) at hello.c:6<br />#1  0x00007ffff7a5f630 in __libc_start_main (main=0x400556 &lt;main>,<br />    argc=1, argv=0x7fffffffd7f8, init=&lt;optimized out>,<br />    fini=&lt;optimized out>, rtld_fini=&lt;optimized out>,<br />    stack_end=0x7fffffffd7e8)<br />    at libc-start.c:289<br />#2  0x0000000000400489 in _start ()<br />-------------------------------------------------------------------<br /><br />That's much better! As we can see, the first function that's really<br />called is _start, which then calls __libc_start_main which is<br />clearly a standard library initialization function which then calls<br />main.<br /><br />You can go take a look at _start __libc_start_main in glibc source<br />if you want, but it's not very interesting for us as it sets up a<br />bunch of stuff for dynamic linking and such that we will never use<br />since we want a static executable.<br /><br />Let's recompile our hello world with optimization (-O2), without<br />debug information and with stripping (-s) to see how large it is:<br />-------------------------------------------------------------------<br />$ gcc -s -O2 hello.c<br />$ wc -c a.out<br />6208 a.out<br />-------------------------------------------------------------------<br />6kb for a simple hello world? that's a lot!<br /><br />Even if I add other size optimization flags such as<br />-Wl,--gc-sections -fno-unwind-tables<br />-fno-asynchronous-unwind-tables -Os it just won't go below 6kb.<br /><br />We will now progressively strip this program down by first getting<br />rid of the standard library and then learning how to invoke<br />syscalls without having to include any headers.<br /><br />So how do we get rid of the standard library? If we try to compile<br />our current code with -nostdlib we will run into linker errors:<br />-------------------------------------------------------------------<br />$ gcc -s -O2 -nostdlib hello.c<br />/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.3/../../../../x86_64-pc-linux-<br />gnu/bin/ld: warning: cannot find entry symbol _start; defaulting to<br />0000000000400120<br />/tmp/ccTn8ClC.o: In function `main':<br />hello.c:(.text.startup+0xa): undefined reference to `puts'<br />collect2: error: ld returned 1 exit status<br />-------------------------------------------------------------------<br /><br />The linker is complaining about _start missing, which is what we<br />would expect from our previous debugging.<br /><br />We also have a linker error on puts, which is to be expected since<br />it's a libc function. But how do we print "hello" without puts?<br /><br />The linux kernel exposes a bunch of syscalls, which are functions<br />that user-space programs can enter to interact with the OS.<br />You can see a list of syscalls by running "man syscalls" or<br />visiting this site:<br />http://man7.org/linux/man-pages/man2/syscalls.2.html<br /><br />How do we find out which syscall puts uses? We can either look<br />through the syscall list, or simply install strace to trace<br />syscalls and write a simple program that uses puts.<br /><br />The strace method is extremely useful. If you don't know how to<br />do something with syscalls, do it with libc and then strace it to<br />see which syscalls it uses on the target architecture.<br />-------------------------------------------------------------------<br />$ cat > puts.c &lt;&lt; "EOF"<br />#include &lt;stdio.h><br /><br />int main(int argc, char* argv[])<br />{<br />    puts("hello");<br /><br />    return 0;<br />}<br />EOF<br /><br />$ gcc puts.c<br />$ strace ./a.out > /dev/null<br />- stuff we don't care about -<br />write(1, "hello\n", 6)                  = 6<br />exit_group(0)                           = ?<br />+++ exited with 0 +++<br />-------------------------------------------------------------------<br /><br />So it's using the write syscall.<br /><br />Note how I pipe stdout to /dev/null in strace? That's because<br />strace output is in stderr and we don't want to have it mixed with<br />a.out's output.<br /><br />Let's check the manpage for write:<br />-------------------------------------------------------------------<br />$ man 2 write<br />SYNOPSIS<br />       #include &lt;unistd.h><br /><br />       ssize_t write(int fd, const void *buf, size_t count);<br /><br />DESCRIPTION<br />       write()  writes  up  to  count bytes from the buffer pointed<br />       buf to the file referred to by the file descriptor fd.<br />-------------------------------------------------------------------<br /><br />In linux, there are 3 standard file descriptors:<br />- stdin: used to pipe data into the program or to read user input.<br />- stdout: output<br />- stderr: alternate output for error messages<br /><br />If we read "man stdout", we will see that they are simply defined<br />as 0, 1 and 2.<br /><br />So all we have to do is replace our puts with a write to stream 1<br />(stdout).<br />-------------------------------------------------------------------<br />#include &lt;unistd.h><br /><br />int main(int argc, char* argv[])<br />{<br />    write(1, "hello\n", 6);<br /><br />    return 0;<br />}<br />-------------------------------------------------------------------<br /><br />Let's try to compile it again:<br />-------------------------------------------------------------------<br />$ gcc -s -O2 -nostdlib hello.c<br />hello.c: In function ?main?:<br />hello.c:6:5: warning: ignoring return value of ?write?, declared<br />with attribute warn_unused_result [-Wunused-result]<br />     write(1, "hello\n", 6);<br />     ^<br />/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.3/../../../../x86_64-pc-linux-<br />gnu/bin/ld: warning: cannot find entry symbol _start; defaulting to<br />0000000000400120<br />/tmp/ccJXwSsr.o: In function `main':<br />hello.c:(.text.startup+0x14): undefined reference to `write'<br />collect2: error: ld returned 1 exit status<br />-------------------------------------------------------------------<br /><br />Oh no! The "write" function is part of the standard library!<br />How do we invoke syscalls without having to link the standard lib?<br /><br />Let's take a look at section "A.2.1 Calling Conventions" of the<br />AMD64 ABI specification. If you are on i386 (32-bit), just follow<br />along, we will port this to i386 soon in a moment.<br /><br />If you're completely clueless about asm, you should still be<br />able to understand once you see the example. I'm not that good<br />at asm myself.<br /><br />https://software.intel.com/sites/default/files/article/402129/<br />mpx-linux64-abi.pdf<br /><br />-------------------------------------------------------------------<br />1. User-level applications use as integer registers for passing the<br />sequence %rdi, %rsi, %rdx, %rcx, %r8 and %r9. The kernel interface<br />uses %rdi, %rsi, %rdx, %r10, %r8 and %r9.<br /><br />2. A system-call is done via the syscall instruction. The kernel<br />destroys registers %rcx and %r11.<br /><br />3. The number of the syscall has to be passed in register %rax.<br /><br />4. System-calls are limited to six arguments, no argument is passed<br />directly on the stack.<br /><br />5. Returning from the syscall, register %rax contains the result of<br />the system-call. A value in the range between -4095 and -1<br />indicates an error, it is -errno.<br /><br />6. Only values of class INTEGER or class MEMORY are passed to the<br />kernel.<br />-------------------------------------------------------------------<br /><br />In poor words, all we need to do is write an asm wrapper that:<br /><br />- takes the syscall number followed by either pointers or integers<br />  as parameters<br />- sets rax to the syscall number<br />- sets rdi, rsi, rdx, r10, r8 and r9 to the parameters. calls that<br />  take less than 6 parameters will ignore the excess ones.<br />- executes "syscall"<br />- returns the contents of rax<br /><br />Now if we read section 3.4 of the specification or the quick<br />cheatsheet at http://wiki.osdev.org/Calling_Conventions , we will<br />see that on AMD64 the registers used to pass parameters to regular<br />functions are almost the same as the syscalls, except for r10 which<br />is replaced with rcx. The return register is also the same (rax).<br /><br />This means that our syscall wrapper will only be able to accept and<br />forward a maximum of 5 parameters (because the first parameter is<br />already being used to pass the syscall number).<br /><br />We could use the stack to take more than 6 parameters, but let's<br />not make our lives more complicated when we don't even need to call<br />syscalls with 6 parameters yet.<br /><br />The abi also states that:<br />-------------------------------------------------------------------<br />Registers %rbp, %rbx and %r12 through %r15 ?belong? to the calling<br />function and the called function is required to preserve their<br />values. In other words, a called function must preserve these<br />registers? values for its caller. Remaining registers ?belong? to<br />the called function. If a calling function wants to preserve such a<br />register value across a function call, it must save the value in<br />its local stack frame.<br />-------------------------------------------------------------------<br /><br />Which means that we don't have to worry about saving and restoring<br />the values of rdi, rsi, rdx, r10, r8 and r9 inside of our syscall<br />wrapper, because it's up to the caller to save them and gcc will<br />take care of that (since we will be calling it from C code).<br /><br />Putting it all together, this will be our syscall wrapper (in intel<br />syntax):<br />-------------------------------------------------------------------<br />mov rax,rdi    /* rax (syscall number)  = func param 1 (rdi) */<br />mov rdi,rsi    /* rdi (syscall param 1) = func param 2 (rsi) */<br />mov rsi,rdx    /* rsi (syscall param 2) = func param 3 (rdx) */<br />mov rdx,rcx    /* rdx (syscall param 3) = func param 4 (rcx) */<br />mov r10,r8     /* r10 (syscall param 4) = func param 5 (r8)  */<br />mov r8,r9      /* r8  (syscall param 5) = func param 6 (r9)  */<br />syscall        /* enter the syscall (return value will be in rax */<br />ret            /* return value is already in rax, we can return */<br />-------------------------------------------------------------------<br /><br />How do we embed arbitrary asm into our program though? One way is<br />gcc inline assembler, but I personally find the syntax ugly.<br /><br />We're going to write a .S file in GAS (GNU Assembler) syntax and<br />let gcc compile and link it with your hello.c .<br />-------------------------------------------------------------------<br />cat > hello.S &lt;&lt; "EOF"<br />/* enable intel asm syntax without the % prefix for registers */<br />.intel_syntax noprefix<br /><br />/* this marks the .text section of a PE executable, which contains<br />   program code */<br />.text<br />    /* exports syscall5 to other compilation units (files) */<br />    .globl syscall5<br /><br />    syscall5:<br />        mov rax,rdi<br />        mov rdi,rsi<br />        mov rsi,rdx<br />        mov rdx,rcx<br />        mov r10,r8<br />        mov r8,r9<br />        syscall<br />        ret<br />EOF<br />-------------------------------------------------------------------<br /><br />You can find syscalls numbers here:<br />http://betteros.org/ref/syscall.php<br />https://filippo.io/linux-syscall-table/<br /><br />Or by simply letting the C preprocessor print it for you:<br />-------------------------------------------------------------------<br />$ printf "#include &lt;sys/syscall.h>\nblah SYS_write" | \<br />  gcc -E - | grep blah<br />blah 1<br />-------------------------------------------------------------------<br />-E runs the preprocessor on the file, expanding all macros and<br />therefore replacing #define consts with their value, while - means<br />that we use stdin as input (which we pipe in from printf).<br />Then we just mark a line with blah so we can grep it, followed by<br />the constant we want to know.<br />Syscall numbers are usually named SYS_ followed by the syscall name<br />You can also add the -m32 flags to check values for 32-bit (i386).<br /><br />Remember the prototype for write from earlier?<br />-------------------------------------------------------------------<br />ssize_t write(int fd, const void *buf, size_t count);<br />-------------------------------------------------------------------<br /><br />ssize_t and size_t are types defined by unistd. A quick inspection<br />reveals that they are 64-bit integers and that the extra s in<br />ssize means signed:<br />-------------------------------------------------------------------<br />$ printf "#include &lt;unistd.h>" | gcc -E - | grep size_t<br />typedef long int __blksize_t;<br />typedef long int __ssize_t;<br />typedef __ssize_t ssize_t;<br />typedef long unsigned int size_t;<br />-------------------------------------------------------------------<br /><br />If we try -m32 we will also see that this will be a 32-bit integer<br />on 32-bit, which means that it's the same size as the<br />architecture's pointers. I like to call this kind of integer<br />intptr.<br /><br />Now we can import syscall5 in hello.c and make a write function<br />that calls it:<br />-------------------------------------------------------------------<br />void* syscall5(<br />    void* number,<br />    void* arg1,<br />    void* arg2,<br />    void* arg3,<br />    void* arg4,<br />    void* arg5<br />);<br /><br />typedef unsigned long int uintptr; /* size_t */<br />typedef long int intptr; /* ssize_t */<br /><br />static<br />intptr write(int fd, void const* data, uintptr nbytes)<br />{<br />    return (intptr)<br />        syscall5(<br />            (void*)1, /* SYS_write */<br />            (void*)(intptr)fd,<br />            (void*)data,<br />            (void*)nbytes,<br />            0, /* ignored */<br />            0  /* ignored */<br />        );<br />}<br /><br />int main(int argc, char* argv[])<br />{<br />    write(1, "hello\n", 6);<br /><br />    return 0;<br />}<br />-------------------------------------------------------------------<br /><br />See that (void*)(intptr) double cast on fd? If fd is 32-bit and<br />void* is 64-bit, we would get a warning that we are implicitly<br />casting it to a different size, so we need to explicitly specify<br />that we want that conversion by adding the intptr cast.<br /><br />This should be done every time you cast to and from pointers when<br />the destination type is not guaranteed to be the same size as<br />pointers. Especially when targeting multiple architectures.<br /><br />Also note how we cast the const qualifier away from data to avoid<br />a warning.<br /><br />If we compile now, we are finally only missing _start!<br />-------------------------------------------------------------------<br />$ gcc -s -O2 -nostdlib hello.S hello.c<br />/usr/lib/gcc/x86_64-pc-linux-gnu/4.9.3/../../../../<br />x86_64-pc-linux-gnu/bin/ld: warning: cannot find entry symbol<br />_start; defaulting to 0000000000400120<br />-------------------------------------------------------------------<br /><br />So, how do we define _start? Where do we get argc and argv from?<br />We need to know the initial state of registers and the stack.<br /><br />Back to the AMD64 ABI document. In figure 3.9, we can see the<br />initial state of the stack:<br /><br />0 to rsp: undefined<br />rsp          : argc      &lt;- top of the stack (last pushed value)<br />rsp+8        : argv[0]<br />rsp+16       : argv[1]<br />rsp+24       : argv[2]<br />...          : ...<br />rsp+8*argc   : argv[argc - 1]<br />rsp+8+8*argc : 0<br />* more stuff we don't care about *<br /><br />And right below it we have the initial state of the registers:<br />-------------------------------------------------------------------<br />%rbp: The content of this register is unspecified at process<br />      initialization time, but the user code should mark the<br />      deepest stack frame by setting the frame pointer to zero.<br /><br />%rsp: The stack pointer holds the address of the byte with lowest<br />      address which is part of the stack. It is guaranteed to be<br />      16-byte aligned at process entry.<br /><br />%rdx: a function pointer that the application should register with<br />      atexit (BA_OS).<br />-------------------------------------------------------------------<br /><br />So we know that rbp must be zeroed and that rsp points to the top<br />of the stack. We don't care about rdx.<br /><br />If you don't understand how the stack works, it's basically a<br />chunk of memory where data is appended (pushed) or retrieved (pop)<br />at the end.<br /><br />In AMD64's convention we're actually prepending and removing data<br />at the beginning of the block of memory since the stack is said to<br />"grow downwards", which means that when we push something on the<br />stack, the stack pointer gets lower.<br /><br />Since the ABI states that the stack pointer is 16-byte aligned, we<br />must remember always push data whose size is a multiple of 16. For<br />example, 2 64-bit integers are 16 bytes. It's often necessary to<br />either push useless data or simply align the stack pointer when<br />the pushed values don't happen to be aligned.<br /><br />Putting it all together, our _start function needs to:<br />- zero rbp<br />- put argc into rdi (1st parameter for main)<br />- put the stack address of argv[0] into rsi (2nd param for main),<br />  which will be interpreted as an array of char pointers.<br />- align stack to 16-bytes<br />- call main<br /><br />Here's our new hello.S:<br />-------------------------------------------------------------------<br />.intel_syntax noprefix<br />.text<br />    .globl _start, syscall5<br /><br />    _start:<br />        xor rbp,rbp /* xoring a value with itself = 0 */<br />        pop rdi /* rdi = argc */<br />        /* the pop instruction already added 8 to rsp */<br />        mov rsi,rsp /* rest of the stack as an array of char ptr */<br /><br />        /* zero the las 4 bits of rsp, aligning it to 16 bytes<br />           same as "and rsp,0xfffffffffffffff0" because negative<br />           numbers are represented as<br />           max_unsigned_value + 1 - abs(negative_num) */<br />        and rsp,-16<br />        call main<br />        ret<br /><br />    syscall5:<br />        mov rax,rdi<br />        mov rdi,rsi<br />        mov rsi,rdx<br />        mov rdx,rcx<br />        mov r10,r8<br />        mov r8,r9<br />        syscall<br />        ret<br />-------------------------------------------------------------------<br /><br />It finally compiles! It runs correctly, but we get a segmentation<br />fault when we exit:<br />-------------------------------------------------------------------<br />$ gcc -s -O2 -nostdlib hello.S hello.c<br />$ ./a.out<br />hello<br />Segmentation fault<br />-------------------------------------------------------------------<br /><br />But why?<br /><br />When we execute a call instruction, the return address (address of<br />the intruction to jump to after the function returns) is pushed<br />onto the stack implicitly and the ret instruction implicitly pops<br />it and jumps to it.<br /><br />The _start function is very special, as it has no return address,<br />so our ret instruction in _start is trying to jump back to an<br />invalid memory location, executing garbage data as code or<br />triggering access violations.<br /><br />We need to tell the OS to kill our process and never reach the ret<br />in _start. The syscall _EXIT(2) is just what we need:<br />-------------------------------------------------------------------<br />$ man 2 _EXIT<br />NAME<br />       _exit, _Exit - terminate the calling process<br /><br />SYNOPSIS<br />       #include &lt;unistd.h><br /><br />       void _exit(int status);<br /><br />       #include &lt;stdlib.h><br /><br />       void _Exit(int status);<br /><br />$ printf "#include &lt;sys/syscall.h>\nblah SYS_exit" | \<br />  gcc -E - | grep blah<br />blah 60<br />-------------------------------------------------------------------<br /><br />The status code will simply be the return value of main, which is<br />stored in rax as we know.<br /><br />New hello.S:<br />-------------------------------------------------------------------<br />.intel_syntax noprefix<br />.text<br />    .globl _start, syscall5<br /><br />    _start:<br />        xor rbp,rbp<br />        pop rdi<br />        mov rsi,rsp<br />        and rsp,-16<br />        call main<br /><br />        mov rdi,rax /* syscall param 1 = rax (ret value of main) */<br />        mov rax,60 /* SYS_exit */<br />        syscall<br /><br />        ret /* should never be reached, but if the OS somehow fails<br />               to kill us, it will cause a segmentation fault */<br /><br />    syscall5:<br />        mov rax,rdi<br />        mov rdi,rsi<br />        mov rsi,rdx<br />        mov rdx,rcx<br />        mov r10,r8<br />        mov r8,r9<br />        syscall<br />        ret<br />-------------------------------------------------------------------<br /><br />Our program finally runs and terminates correctly! Let's give<br />ourselves a good pat on the back.<br />-------------------------------------------------------------------<br />$ gcc -s -O2 -nostdlib hello.S hello.c<br />$ ./a.out<br />hello<br />-------------------------------------------------------------------<br /><br />Let's check the executable size now:<br />-------------------------------------------------------------------<br />$ wc -c a.out<br />1008 a.out<br />-------------------------------------------------------------------<br /><br />We're almost below 1kb and it's 6 times smaller than before, but we<br />can shrink it further.<br /><br />First of all, gcc generates unwind tables by default, which are<br />used for exception handling and other stuff we don't care about.<br /><br />Let's turn those off:<br />-------------------------------------------------------------------<br />$ gcc -s -O2 \<br />    -nostdlib \<br />    -fno-unwind-tables \<br />    -fno-asynchronous-unwind-tables \<br />    hello.S hello.c<br /><br />$ wc -c a.out<br />736 a.out<br />-------------------------------------------------------------------<br /><br />Woah, we shaved almost 300 bytes off!<br /><br />As a last step, we can check the executable for useless sections:<br />-------------------------------------------------------------------<br />$ objdump -x a.out<br /><br />a.out:     file format elf64-x86-64<br />a.out<br />architecture: i386:x86-64, flags 0x00000102:<br />EXEC_P, D_PAGED<br />start address 0x000000000040011a<br /><br />Program Header:<br />    LOAD off    0x0000000000000000 vaddr 0x0000000000400000<br />         paddr 0x0000000000400000 align 2**21<br />         filesz 0x0000000000000153 memsz 0x0000000000000153<br />         flags r-x<br />   STACK off    0x0000000000000000 vaddr 0x0000000000000000<br />         paddr 0x0000000000000000 align 2**4<br />         filesz 0x0000000000000000 memsz 0x0000000000000000<br />         flags rwx<br />PAX_FLAGS off    0x0000000000000000 vaddr 0x0000000000000000<br />         paddr 0x0000000000000000 align 2**3<br />         filesz 0x0000000000000000 memsz 0x0000000000000000<br />         flags --- 2800<br /><br />Sections:<br />Idx Name          Size      VMA               LMA               ...<br />  0 .text         0000005c  00000000004000f0  00000000004000f0  ...<br />                  CONTENTS, ALLOC, LOAD, READONLY, CODE<br />  1 .rodata       00000007  000000000040014c  000000000040014c  ...<br />                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br />  2 .comment      0000002a  0000000000000000  0000000000000000  ...<br />                  CONTENTS, READONLY<br />SYMBOL TABLE:<br />no symbols<br />-------------------------------------------------------------------<br /><br />.text is the code<br />.rodata is Read Only data (such as the string "hello" in our case)<br /><br />So we need both of these.<br /><br />But what's that .comment section?<br />-------------------------------------------------------------------<br />$ objdump -s -j .comment a.out<br /><br />a.out:     file format elf64-x86-64<br /><br />Contents of section .comment:<br /> 0000 4743433a 20284765 6e746f6f 20342e39  GCC: (Gentoo 4.9<br /> 0010 2e332070 312e352c 20706965 2d302e36  .3 p1.5, pie-0.6<br /> 0020 2e342920 342e392e 3300               .4) 4.9.3.<br />-------------------------------------------------------------------<br /><br />Just information about the compiler, it seems. That's 1 byte for<br />every character of that string, let's get rid of it!<br />-------------------------------------------------------------------<br />$ strip -R .comment a.out<br />$ wc -c a.out<br />624 a.out<br />-------------------------------------------------------------------<br /><br />There we go, we have achieved a nearly ten-fold size improvement<br />on our little hello world.<br /><br />Let's set up a build script with all those compiler flags and let's<br />also make it output the executable with a proper name.<br /><br />Also, I'm going to add the following useful flags:<br /><br />-Wl,--gc-sections: get rid of any unused code sections<br /><br />-fdata-sections: separate each function into its own code section.<br />                 this lets gc-sections do its job. these two<br />                 options combined will get rid of any dead code you<br />                 might accidentally leave in your program. it also<br />                 gets rid of unused functions in statically linked<br />                 libraries.<br /><br />-fno-stack-protector: doesn't generate extra code to guard against<br />                      overflows overwriting the return address.<br /><br />-Wa,--noexecstack: mark the stack memory as non-executable. this is<br />                   just extra security since we don't need to be<br />                   executing code off the stack's memory.<br /><br />-fno-builtin: disable all builtin gcc functions (such as math<br />              routines and other stuff). we will implement them<br />              ourselves as needed.<br /><br />-std=c89 -pedantic: follow the old c89 standard strictly. this<br />                    should force us to write code more compatible<br />                    with old compilers.<br /><br />-Wall: enable all warnings.<br />-Werror: treat all warnings as error. can't let our code build with<br />         unchecked warnings.<br /><br />-------------------------------------------------------------------<br />$ cat > build.sh &lt;&lt; "EOF"<br />#!/bin/sh<br /><br />exename="hello"<br /><br />gcc -std=c89 -pedantic -s -O2 -Wall -Werror \<br />    -nostdlib \<br />    -fno-unwind-tables \<br />    -fno-asynchronous-unwind-tables \<br />    -fdata-sections \<br />    -Wl,--gc-sections \<br />    -Wa,--noexecstack \<br />    -fno-builtin \<br />    -fno-stack-protector \<br />    hello.S hello.c \<br />    -o $exename \<br />\<br />&amp;&amp; strip -R .comment $exename<br />EOF<br /><br />$ chmod +x ./build.sh<br />$ ./build.sh<br />$ wc -c hello<br />624 hello<br />$ ./hello<br />hello<br />-------------------------------------------------------------------<br /><br />As you might have noticed, we are doing a lot of useless mov's in<br />that syscall5 wrapper on syscalls that take less than 5 parameters.<br /><br />Let's make one wrapper for each parameter count. This will increase<br />performance slightly at the cost of a slightly bigger executable.<br /><br />You are free to remove the ones you don't use once you finish<br />prototyping your program.<br /><br />New hello.S<br />-------------------------------------------------------------------<br />.intel_syntax noprefix<br />.text<br />    .globl _start, syscall,<br />    .globl syscall1, syscall2, syscall3, syscall4, syscall5<br /><br />    _start:<br />        xor rbp,rbp<br />        pop rdi<br />        mov rsi,rsp<br />        and rsp,-16<br />        call main<br />        mov rdi,rax<br />        mov rax,60 /* SYS_exit */<br />        syscall<br />        ret<br /><br />    syscall:<br />        mov rax,rdi<br />        syscall<br />        ret<br /><br />    syscall1:<br />        mov rax,rdi<br />        mov rdi,rsi<br />        syscall<br />        ret<br /><br />    syscall2:<br />        mov rax,rdi<br />        mov rdi,rsi<br />        mov rsi,rdx<br />        syscall<br />        ret<br /><br />    syscall3:<br />        mov rax,rdi<br />        mov rdi,rsi<br />        mov rsi,rdx<br />        mov rdx,rcx<br />        syscall<br />        ret<br /><br />    syscall4:<br />        mov rax,rdi<br />        mov rdi,rsi<br />        mov rsi,rdx<br />        mov rdx,rcx<br />        mov r10,r8<br />        syscall<br />        ret<br /><br />    syscall5:<br />        mov rax,rdi<br />        mov rdi,rsi<br />        mov rsi,rdx<br />        mov rdx,rcx<br />        mov r10,r8<br />        mov r8,r9<br />        syscall<br />        ret<br />-------------------------------------------------------------------<br /><br />Now we can change our write function to use syscall3 instead.<br /><br />We will also change argv in our main to be char const* since we<br />probably won't be modifying it. This is normally not allowed on the<br />standard C library, but we aren't using it :^).<br /><br />Using the syscall numbers directly is a bit hard to read so let's<br />also make a header with all the syscall numbers we use:<br />-------------------------------------------------------------------<br />$ cat > syscalls.h &lt;&lt; "EOF"<br />#define SYS_write 1<br />#define SYS_exit  60<br />EOF<br />-------------------------------------------------------------------<br /><br />We will also define the syscall number as uintptr so that we don't<br />need to cast to void*.<br /><br />new hello.c<br />-------------------------------------------------------------------<br />#include "syscalls.h"<br /><br />typedef unsigned long int uintptr;<br />typedef long int intptr;<br /><br />void* syscall3(<br />    uintptr number,<br />    void* arg1,<br />    void* arg2,<br />    void* arg3<br />);<br /><br />static<br />intptr write(int fd, void const* data, uintptr nbytes)<br />{<br />    return (uintptr)<br />        syscall3(<br />            SYS_write,<br />            (void*)(intptr)fd,<br />            (void*)data,<br />            (void*)nbytes<br />        );<br />}<br /><br />int main(int argc, char const* argv[])<br />{<br />    write(1, "hello\n", 6);<br /><br />    return 0;<br />}<br />-------------------------------------------------------------------<br /><br />We can include headers in .S files, so let's also include it in<br />hello.S<br />-------------------------------------------------------------------<br />#include "syscalls.h"<br /><br />.intel_syntax noprefix<br />.text<br />    .globl _start, syscall,<br />    .globl syscall1, syscall2, syscall3, syscall4, syscall5<br /><br />    _start:<br />        xor rbp,rbp<br />        pop rdi<br />        mov rsi,rsp<br />        and rsp,-16<br />        call main<br />        mov rdi,rax<br />        mov rax,SYS_exit<br />        syscall<br />        ret<br /><br />...<br />-------------------------------------------------------------------<br /><br />Having to pass the string length every time is annoying, so let's<br />implement our own strlen and puts.<br /><br />I'm also going to make a "internal" alias for static, which makes<br />it easier to search for static functions, rather than static<br />variables, in a large codebase. I got this idea from Casey Muratori<br />from handmade hero.<br /><br />-------------------------------------------------------------------<br />#include "syscalls.h"<br /><br />typedef unsigned long int uintptr;<br />typedef long int intptr;<br /><br />#define internal static<br /><br />void* syscall3(<br />    uintptr number,<br />    void* arg1,<br />    void* arg2,<br />    void* arg3<br />);<br /><br />/* ------------------------------------------------------------- */<br /><br />#define stdout 1<br /><br />internal<br />intptr write(int fd, void const* data, uintptr nbytes)<br />{<br />    return (uintptr)<br />        syscall3(<br />            SYS_write,<br />            (void*)(intptr)fd,<br />            (void*)data,<br />            (void*)nbytes<br />        );<br />}<br /><br />/* ------------------------------------------------------------- */<br /><br />internal<br />uintptr strlen(char const* str)<br />{<br />    char const* p;<br />    for (p = str; *p; ++p);<br />    return p - str;<br />}<br /><br />internal<br />uintptr puts(char const* str) {<br />    return write(stdout, str, strlen(str));<br />}<br /><br />/* ------------------------------------------------------------- */<br /><br />int main(int argc, char const* argv[])<br />{<br />    puts("hello\n");<br /><br />    return 0;<br />}<br />-------------------------------------------------------------------<br /><br />If you don't understand my strlen function, it's pretty simple: C<br />strings are null-terminated (the byte after the last character is<br />zero), so I just iterate the characters through a pointer until<br />I find a zero byte, and then I subtract the current position from<br />the beginning of the string.<br /><br />libc does all kinds of crazy tricks to optimize this for large<br />strings, which I haven't looked into.<br /><br />As you can see, I've also separated the code into sections with<br />those spacer comments for readability. I grouped all the syscall<br />wrappers together, followed by utility functions, followed by<br />the program's code.<br /><br />Now we have a nice framework for AMD64 programs, but we're not<br />going to stop here. We're going to set this up to also cross<br />compile for i386, which is a very common architecture in low-end<br />servers (such as the one I host my gopher mirror on).<br /><br />###################################################################<br />                          Porting to i386<br />###################################################################<br />Let's move all the AMD64-specific code into a dedicated folder.<br />-------------------------------------------------------------------<br />$ mkdir amd64<br />$ mv hello.S amd64/start.S<br />$ mv syscalls.h amd64/<br />-------------------------------------------------------------------<br /><br />Now we can make a architecture-specific main.c where we define the<br />integer types and main, which just calls hello_run, or whatever you<br />want to name your program's entry point. This file includes hello.c<br />just before main.<br /><br />I also make it define AMD64 in case we need to do platform checking<br />in the code. Platform specific code should be kept separated<br />whenever possible, though.<br /><br />-------------------------------------------------------------------<br />$ cat > amd64/main.c &lt;&lt; "EOF"<br />#define AMD64<br />#include "syscalls.h"<br /><br />typedef unsigned long int  u64;<br />typedef unsigned int       u32;<br />typedef unsigned short int u16;<br />typedef unsigned char      u8;<br /><br />typedef long int    i64;<br />typedef int         i32;<br />typedef short int   i16;<br />typedef signed char i8;<br /><br />typedef i64 intptr;<br />typedef u64 uintptr;<br /><br />#include "../hello.c"<br /><br />int main(int argc, char const* argv[]) {<br />    return hello_run(argc, argv);<br />}<br />EOF<br />-------------------------------------------------------------------<br /><br />Yes, you can include .c files, which just get pasted into the file.<br />This results in a single compilation unit even though we have<br />multiple files, which speeds up compilation (unless your project is<br />massive) and saves us the pain of typing every filename in our<br />build script. This is yet another tick I got from Casey.<br /><br />By the way, you can check integer types on any architecture with<br />the usual gcc preprocessor trick:<br />-------------------------------------------------------------------<br />$ printf "#include &lt;stdint.h>" | gcc -E - | grep int64<br />typedef long int int64_t;<br />typedef unsigned long int uint64_t;<br /><br />$ printf "#include &lt;stdint.h>" | gcc -E - | grep int32<br />typedef int int32_t;<br />typedef unsigned int uint32_t;<br /><br />$ printf "#include &lt;stdint.h>" | gcc -E - | grep int16<br />typedef short int int16_t;<br />typedef unsigned short int uint16_t;<br /><br />$ printf "#include &lt;stdint.h>" | gcc -E - | grep int8<br />typedef signed char int8_t;<br />typedef unsigned char uint8_t;<br />-------------------------------------------------------------------<br /><br />And for the size of pointers, you can write a simple program that<br />printfs sizeof(void*).<br /><br />hello.c will now look like this (remember, we moved the integer<br />definitions to main.c and renamed main to hello_run, and<br />syscalls.h is already included in main.c):<br /><br />-------------------------------------------------------------------<br />#define internal static<br /><br />void* syscall3(<br />    uintptr number,<br />    void* arg1,<br />    void* arg2,<br />    void* arg3<br />);<br /><br />/* ------------------------------------------------------------- */<br /><br />#define stdout 1<br /><br />internal<br />intptr write(int fd, void const* data, uintptr nbytes)<br />{<br />    return (uintptr)<br />        syscall3(<br />            SYS_write,<br />            (void*)(intptr)fd,<br />            (void*)data,<br />            (void*)nbytes<br />        );<br />}<br /><br />/* ------------------------------------------------------------- */<br /><br />internal<br />uintptr strlen(char const* str)<br />{<br />    char const* p;<br />    for (p = str; *p; ++p);<br />    return p - str;<br />}<br /><br />internal<br />uintptr puts(char const* str) {<br />    return write(stdout, str, strlen(str));<br />}<br /><br />/* ------------------------------------------------------------- */<br /><br />internal<br />int hello_run(int argc, char const* argv[])<br />{<br />    puts("hello\n");<br /><br />    return 0;<br />}<br />-------------------------------------------------------------------<br /><br />Modify the build script to follow the new structure:<br />-------------------------------------------------------------------<br />#!/bin/sh<br /><br />exename="hello"<br /><br />gcc -std=c89 -pedantic -s -O2 -Wall -Werror \<br />    -nostdlib \<br />    -fno-unwind-tables \<br />    -fno-asynchronous-unwind-tables \<br />    -fdata-sections \<br />    -Wl,--gc-sections \<br />    -Wa,--noexecstack \<br />    -fno-builtin \<br />    -fno-stack-protector \<br />    amd64/start.S amd64/main.c \<br />    -o $exename \<br />\<br />&amp;&amp; strip -R .comment $exename<br />-------------------------------------------------------------------<br /><br />Now we can create the main.c for i386:<br />-------------------------------------------------------------------<br />$ mkdir i386<br />$ cat > i386/main.c &lt;&lt; "EOF"<br />#define I386<br />#include "syscalls.h"<br /><br />typedef unsigned long long int u64;<br />typedef unsigned int           u32;<br />typedef unsigned short int     u16;<br />typedef unsigned char          u8;<br /><br />typedef long long int i64;<br />typedef int           i32;<br />typedef short int     i16;<br />typedef signed char   i8;<br /><br />typedef i32 intptr;<br />typedef u32 uintptr;<br /><br />#include "../hello.c"<br /><br />int main(int argc, char const* argv[]) {<br />    return hello_run(argc, argv);<br />}<br />EOF<br />-------------------------------------------------------------------<br /><br />Note how intptr is defined as a 32-bit integer and u64 is long<br />long on 32-bits.<br /><br />Let's now grab syscall numbers for i386 and throw them into<br />syscalls.h:<br />-------------------------------------------------------------------<br />$ printf "#include &lt;sys/syscall.h>\nblah SYS_write" \<br />  | gcc -m32 -E - | grep blah<br />blah 4<br /><br />$ printf "#include &lt;sys/syscall.h>\nblah SYS_exit" \<br />  | gcc -m32 -E - | grep blah<br />blah 1<br /><br />$ cat > i386/syscalls.h &lt;&lt; "EOF"<br />#define SYS_write 4<br />#define SYS_exit  1<br />EOF<br />-------------------------------------------------------------------<br /><br />We need to write a i386 start.S and you guessed it, it's time to<br />look at the ABI specification once again!<br /><br />http://www.sco.com/developers/devspecs/abi386-4.pdf<br /><br />This time I will just summarize the differences from amd64:<br /><br />- Registers are 32-bit so we push 4 bytes at a time.<br /><br />- The stack is aligned to 4 bytes, but we will still align it to<br />  16 bytes because it can improve performance by preventing<br />  misaligned SSE accesses (according to glibc).<br /><br />- ebp needs to be zeroed (32-bit version of rbp)<br /><br />- esp is the stack pointer (32-bit version of rsp)<br /><br />- Return values for functions and syscalls are in eax<br /><br />- The instruction to enter syscalls is "int 0x80"<br /><br />- Syscall parameters are passed in ebx, ecx, edx, esi, edi, ebp<br /><br />- Function parameters are passed entirely through the stack by<br />  pushing them in reverse order, which means that we will be able<br />  to access them sequentially every 4 bytes on the stack.<br />  VERY IMPORTANT DIFFERENCE. We won't be using registers to pass<br />  parameters to main anymore nor to pull parameters in syscall<br />  wrappers.<br /><br />- Functions are expected to preserve ebx, esi, edi, ebp, esp on<br />  their own VERY IMPORTANT! we will have to save and restore these<br />  registers manually in our syscall wrappers!<br /><br />- Function callers are expected to clean up the parameters off the<br />  stack after the call. VERY IMPORTANT<br /><br />- As explained earlier, the return address is implicitly pushed on<br />  the stack so the function parameters will start at esp+4.<br /><br />In short, our _start will look something like this:<br />-------------------------------------------------------------------<br />xor ebp,ebp<br /><br />pop esi /* argc */<br />mov ecx,esp /* argv */<br /><br />/* 16-byte stack alignment is not mandatory here but<br />   according to glibc it improves SSE performance */<br />and esp,-16<br /><br />/* push garbage to align to 16 bytes */<br />push 0xb16b00b5<br />push 0xb16b00b5<br />push ecx /* argv */<br />push esi /* argc */<br />call main<br />add esp,16<br />/* on i386 it's up to the caller to clean up the stack. we can<br />   either pop them into scratch registers or just add the total<br />   size of the parameters in bytes to the stack pointer */<br /><br />mov ebx,eax<br />mov eax,SYS_exit<br />int 0x80<br />ret<br />-------------------------------------------------------------------<br /><br />... and our syscall5 wrapper will look like this:<br />-------------------------------------------------------------------<br />push ebx<br />push esi<br />push edi<br />mov eax,[esp+4+12]<br />mov ebx,[esp+8+12]<br />mov ecx,[esp+12+12]<br />mov edx,[esp+16+12]<br />mov esi,[esp+20+12]<br />mov edi,[esp+24+12]<br />int 0x80<br />pop edi<br />pop esi<br />pop ebx<br />ret<br />-------------------------------------------------------------------<br /><br />See how I'm pushing registers on the stack to preserve them to then<br />pop them (in reverse order since it's LIFO)? That's very important<br />on i386.<br /><br />Also, you might be wondering what's going on with the esp offsets.<br />You have to keep in mind that every time I push a register on the<br />stack, esp is decremented by 4, so I have to skip the registers I<br />pushed on the stack (3 registers = 12 bytes) to get to the<br />parameters. Don't forget that the return address is also on the<br />stack, so parameters start at + 4.<br /><br />And here's our complete i386 start.S<br />-------------------------------------------------------------------<br />$ cat > i386/start.S &lt;&lt; "EOF"<br />#include "syscalls.h"<br /><br />.intel_syntax noprefix<br />.text<br />    .globl _start, syscall<br />    .globl syscall1, syscall2, syscall3, syscall4, syscall5<br /><br />    _start:<br />        xor ebp,ebp<br />        pop esi<br />        mov ecx,esp<br />        and esp,-16<br />        push 0xb1gb00b5<br />        push 0xb1gb00b5<br />        push ecx<br />        push esi<br />        call main<br />        add esp,16<br />        mov ebx,eax<br />        mov eax,SYS_exit<br />        int 0x80<br />        ret<br /><br />    syscall:<br />        mov eax,[esp+4]<br />        int 0x80<br />        ret<br /><br />    syscall1:<br />        push ebx<br />        mov eax,[esp+4+4]<br />        mov ebx,[esp+8+4]<br />        int 0x80<br />        pop ebx<br />        ret<br /><br />    syscall2:<br />        push ebx<br />        mov eax,[esp+4+4]<br />        mov ebx,[esp+8+4]<br />        mov ecx,[esp+12+4]<br />        int 0x80<br />        pop ebx<br />        ret<br /><br />    syscall3:<br />        push ebx<br />        mov eax,[esp+4+4]<br />        mov ebx,[esp+8+4]<br />        mov ecx,[esp+12+4]<br />        mov edx,[esp+16+4]<br />        int 0x80<br />        pop ebx<br />        ret<br /><br />    syscall4:<br />        push ebx<br />        push esi<br />        mov eax,[esp+4+8]<br />        mov ebx,[esp+8+8]<br />        mov ecx,[esp+12+8]<br />        mov edx,[esp+16+8]<br />        mov esi,[esp+20+8]<br />        int 0x80<br />        pop esi<br />        pop ebx<br />        ret<br /><br />    syscall5:<br />        push ebx<br />        push esi<br />        push edi<br />        mov eax,[esp+4+12]<br />        mov ebx,[esp+8+12]<br />        mov ecx,[esp+12+12]<br />        mov edx,[esp+16+12]<br />        mov esi,[esp+20+12]<br />        mov edi,[esp+24+12]<br />        int 0x80<br />        pop edi<br />        pop esi<br />        pop ebx<br />        ret<br />EOF<br />-------------------------------------------------------------------<br /><br />Now we need to modify our build script to handle multiple<br />architectures.<br /><br />I will just make the script take the arch subfolder name as a<br />parameter.<br /><br />This is not enough though, because each architecture will have some<br />extra compiler flags. For example, on i386 we need -m32 to ensure a<br />32-bit build even on amd64 dev machines, as well as -Wno-long-long<br />which suppresses a warning about 64 bit integers being a<br />nonstandard gcc extension on 32-bit.<br /><br />We will make our build script source a flags.sh script in the<br />architecture-specific folder which just exports COMPILER_FLAGS with<br />all the extra stuff it wants.<br /><br />-------------------------------------------------------------------<br />$ cat > build.sh &lt;&lt; "EOF"<br />#!/bin/sh<br /><br />exename="hello"<br />archname=${1:-amd64} # if not specified, default to amd64<br /><br /># if flags.sh exists in the arch folder, source it<br />if [ -e $archname/flags.sh ]; then<br />    source $archname/flags.sh<br />fi<br /><br />gcc -std=c89 -pedantic -s -O2 -Wall -Werror \<br />    -nostdlib \<br />    -fno-unwind-tables \<br />    -fno-asynchronous-unwind-tables \<br />    -fdata-sections \<br />    -Wl,--gc-sections \<br />    -Wa,--noexecstack \<br />    -fno-builtin \<br />    -fno-stack-protector \<br />    $COMPILER_FLAGS \<br />    $archname/start.S $archname/main.c \<br />    -o $exename \<br />\<br />&amp;&amp; strip -R .comment $exename<br />EOF<br /><br />$ cat > i386/flags.sh &lt;&lt; "EOF"<br />#!/bin/sh<br /><br />export COMPILER_FLAGS="-m32 -Wno-long-long"<br />EOF<br />-------------------------------------------------------------------<br /><br />Now we can compile both architectures easily with minimal code<br />redundancy:<br />-------------------------------------------------------------------<br />$ wc -c hello<br />720 hello<br />$ ./hello<br />hello<br />$ ./build.sh i386<br />$ wc -c hello<br />608 hello<br />$ ./hello<br />hello<br />-------------------------------------------------------------------<br /><br />And there you have it! You now have a nice framework to develop<br />libc-free programs.<br /><br />As you can see, the 32-bit executable is slightly smaller. This is<br />mostly because pointers are half as large compared to 64-bit.<br /><br />###################################################################<br />                       Legacy syscalls on i386<br />###################################################################<br />There are a few things you should be extremely careful with when<br />dealing with syscalls, especially when targeting multiple<br />architectures.<br /><br />Some syscalls, such as stat, might return their stuff in a struct.<br />Be extremely careful to check the struct layout and size of the<br />types used, because it will often change drastically between<br />architectures.<br /><br />-------------------------------------------------------------------<br />$ man 2 stat<br />NAME<br />       stat, fstat, lstat, fstatat - get file status<br /><br />SYNOPSIS<br />       #include &lt;sys/types.h><br />       #include &lt;sys/stat.h><br />       #include &lt;unistd.h><br /><br />       int stat(const char *pathname, struct stat *buf);<br />       int fstat(int fd, struct stat *buf);<br />       int lstat(const char *pathname, struct stat *buf);<br /><br />$ printf "#include &lt;sys/stat.h>" | gcc -E - | grep -A 1 "int stat"<br />extern int stat (const char *__restrict __file,<br />   struct stat *__restrict __buf) __attribute__ ((__nothrow__ ,<br />   __leaf__)) __attribute__ ((__nonnull__ (1, 2)));<br />-------------------------------------------------------------------<br /><br />-------------------------------------------------------------------<br />$ printf "#include &lt;sys/stat.h>" \<br />  | gcc -E - | grep -A 60 "struct stat"<br />struct stat<br />{<br />    __dev_t st_dev;<br />    __ino_t st_ino;<br />    __nlink_t st_nlink;<br />    __mode_t st_mode;<br />    __uid_t st_uid;<br />    __gid_t st_gid;<br />    int __pad0;<br />    __dev_t st_rdev;<br />    __off_t st_size;<br />    __blksize_t st_blksize;<br />    __blkcnt_t st_blocks;<br /># 91 "/usr/include/bits/stat.h" 3 4<br />    struct timespec st_atim;<br />    struct timespec st_mtim;<br />    struct timespec st_ctim;<br /># 106 "/usr/include/bits/stat.h" 3 4<br />    __syscall_slong_t __glibc_reserved[3];<br /># 115 "/usr/include/bits/stat.h" 3 4<br />};<br /><br />$ printf "#include &lt;sys/stat.h>" | gcc -E - \<br />  | grep '__dev_t\|__ino_t\|__nlink_t\|__mode_t\|__uid_t\|__gid_t'<br />typedef unsigned long int __dev_t;<br />typedef unsigned int __uid_t;<br />typedef unsigned int __gid_t;<br />typedef unsigned long int __ino_t;<br />typedef unsigned int __mode_t;<br />typedef unsigned long int __nlink_t;<br /><br />$ printf "#include &lt;sys/stat.h>" | gcc -E - \<br />  | grep '__blksize_t\|__blkcnt_t\|__syscall_slong_t\|__off_t'<br />typedef long int __off_t;<br />typedef long int __blksize_t;<br />typedef long int __blkcnt_t;<br />typedef long int __syscall_slong_t;<br /><br />$ printf "#include &lt;sys/stat.h>" | gcc -E - \<br />  | grep -A 10 "struct timespec"<br />struct timespec<br />{<br />    __time_t tv_sec;<br />    __syscall_slong_t tv_nsec;<br />};<br /><br />$ printf "#include &lt;sys/stat.h>" | gcc -E - | grep "__time_t"<br />typedef long int __time_t;<br />-------------------------------------------------------------------<br /><br />-------------------------------------------------------------------<br />$ printf "#include &lt;sys/stat.h>" \<br />  | gcc -m32 -E - | grep -A 60 "struct stat"<br />struct stat<br />{<br />    __dev_t st_dev;<br />    unsigned short int __pad1;<br />    __ino_t st_ino;<br />    __mode_t st_mode;<br />    __nlink_t st_nlink;<br />    __uid_t st_uid;<br />    __gid_t st_gid;<br />    __dev_t st_rdev;<br />    unsigned short int __pad2;<br />    __off_t st_size;<br />    __blksize_t st_blksize;<br />    __blkcnt_t st_blocks;<br /># 91 "/usr/include/bits/stat.h" 3 4<br />    struct timespec st_atim;<br />    struct timespec st_mtim;<br />    struct timespec st_ctim;<br /># 109 "/usr/include/bits/stat.h" 3 4<br />    unsigned long int __glibc_reserved4;<br />    unsigned long int __glibc_reserved5;<br />};<br /><br />$ printf "#include &lt;sys/stat.h>" | gcc -m32 -E - \<br />  | grep '__dev_t\|__ino_t\|__nlink_t\|__mode_t\|__uid_t\|__gid_t'<br />__extension__ typedef __u_quad_t __dev_t;<br />__extension__ typedef unsigned int __uid_t;<br />__extension__ typedef unsigned int __gid_t;<br />__extension__ typedef unsigned long int __ino_t;<br />__extension__ typedef unsigned int __mode_t;<br />__extension__ typedef unsigned int __nlink_t;<br /><br />$ printf "#include &lt;sys/stat.h>" \<br />  | gcc -m32 -E - | grep '__u_quad_t'<br />__extension__ typedef unsigned long long int __u_quad_t;<br /><br />$ printf "#include &lt;sys/stat.h>" | gcc -m32 -E - \<br />  | grep '__blksize_t\|__blkcnt_t\|__syscall_slong_t'<br />__extension__ typedef long int __off_t;<br />__extension__ typedef long int __blksize_t;<br />__extension__ typedef long int __blkcnt_t;<br />__extension__ typedef long int __syscall_slong_t;<br /><br />$ printf "#include &lt;sys/stat.h>" | gcc -m32 -E - \<br />  | grep -A 10 "struct timespec"<br />struct timespec<br />{<br />    __time_t tv_sec;<br />    __syscall_slong_t tv_nsec;<br />};<br /><br />$ printf "#include &lt;sys/stat.h>" | gcc -m32 -E - | grep "__time_t"<br />__extension__ typedef long int __time_t;<br />-------------------------------------------------------------------<br /><br />As you can see, the stat struct is substantially different for<br />i386 and amd64 and the contained types are also different in size.<br /><br />This is not all there is to it though. Some syscalls have multiple<br />versions of them with different structs for historical reasons, and<br />gcc might wrap them in some weird way, using its own struct.<br /><br />stat is one of them. Suppose you use the above structs and assume<br />libc, stat struct is right.<br />Let's make a simple program that stats a file and dumps the stat<br />struct to stdout for us to inspect.<br /><br />These are the files:<br />-------------------------------------------------------------------<br />$ cat amd64/syscalls.h<br />#define SYS_write 1<br />#define SYS_stat  4<br />#define SYS_exit  60<br /><br />$ cat i386/syscalls.h<br />#define SYS_write 4<br />#define SYS_stat 106<br />#define SYS_exit  1<br /><br />$ cat stat.c<br />#define internal static<br /><br />void* syscall2(<br />    uintptr number,<br />    void* arg1,<br />    void* arg2<br />);<br /><br />void* syscall3(<br />    uintptr number,<br />    void* arg1,<br />    void* arg2,<br />    void* arg3<br />);<br /><br />/* ------------------------------------------------------------- */<br /><br />#define stdout 1<br /><br />internal<br />intptr write(int fd, void const* data, uintptr nbytes)<br />{<br />    return (uintptr)<br />        syscall3(<br />            SYS_write,<br />            (void*)(intptr)fd,<br />            (void*)data,<br />            (void*)nbytes<br />        );<br />}<br /><br />typedef u64 dev_t;<br />typedef intptr syscall_slong_t;<br />typedef intptr time_t;<br /><br />typedef struct<br />{<br />    time_t sec;<br />    syscall_slong_t nsec;<br />}<br />timespec;<br /><br />typedef struct<br />{<br />    dev_t dev;<br />#ifdef I386<br />    u16 __pad1;<br />#endif<br />    uintptr ino;<br />    uintptr nlink;<br />    u32 mode;<br />    u32 uid;<br />    u32 gid;<br />#ifdef AMD64<br />    int __pad0;<br />#endif<br />    dev_t rdev;<br />#ifdef I386<br />    u16 __pad2;<br />#endif<br />    intptr size;<br />    intptr blksize;<br />    intptr blocks;<br />    timespec atim;<br />    timespec mtim;<br />    timespec ctim;<br />#ifdef AMD64<br />    syscall_slong_t __glibc_reserved[3];<br />#else<br />    u32 __glibc_reserved4;<br />    u32 __glibc_reserved5;<br />#endif<br />}<br />stat_info;<br /><br />internal<br />int stat(char const* path, stat_info* s)<br />{<br />    return (int)(intptr)<br />        syscall2(<br />            SYS_stat,<br />            (void*)path,<br />            s<br />        );<br />}<br /><br />/* ------------------------------------------------------------- */<br /><br />internal<br />int stat_run(int argc, char const* argv[])<br />{<br />    stat_info si;<br /><br />    if (stat("/etc/hosts", &amp;si) == 0) {<br />        write(stdout, &amp;si, sizeof(stat_info));<br />    }<br /><br />    return 0;<br />}<br />-------------------------------------------------------------------<br /><br />Now if we hexdump output from amd64 and i386, we will see that<br />something is not quite right on i386:<br />-------------------------------------------------------------------<br />$ ./build.sh<br />$ ./stat | hexdump -C<br />00000000  12 08 00 00 00 00 00 00  50 59 0a 00 00 00 00 00<br />00000010  01 00 00 00 00 00 00 00  a4 81 00 00 00 00 00 00<br />00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00<br />00000030  bc 04 00 00 00 00 00 00  00 10 00 00 00 00 00 00<br />00000040  08 00 00 00 00 00 00 00  24 b2 e9 57 00 00 00 00<br />00000050  d1 f4 e1 2f 00 00 00 00  e8 d8 5e 57 00 00 00 00<br />00000060  a0 3a b4 24 00 00 00 00  e8 d8 5e 57 00 00 00 00<br />00000070  20 c8 0f 25 00 00 00 00  00 00 00 00 00 00 00 00<br />00000080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00<br />00000090<br />$ ./build.sh i386<br />$ ./stat | hexdump -C<br />00000000  12 08 00 00 50 59 0a 00  a4 81 01 00 00 00 00 00<br />00000010  00 00 00 00 bc 04 00 00  00 10 00 00 08 00 00 00<br />00000020  24 b2 e9 57 d1 f4 e1 2f  e8 d8 5e 57 a0 3a b4 24<br />00000030  e8 d8 5e 57 20 c8 0f 25  00 00 00 00 00 00 00 00<br />00000040  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00<br />00000050  00 00 00 00 00 00 00 00<br />00000058<br />-------------------------------------------------------------------<br /><br />We know dev_t is a 64-bit integer from our previous investigations,<br />so why is other stuff being packed after the 4th byte? The first<br />8 bytes of the structs should be the same as amd64!<br /><br />If you scroll through the stat manpage, you will find this:<br />-------------------------------------------------------------------<br />Over  time, increases in the size of the stat structure have led to<br />three successive versions of  stat():  sys_stat()  (slot  __NR_old?<br />stat),  sys_newstat()  (slot  __NR_stat),  and  sys_stat64()  (slot<br />__NR_stat64) on 32-bit platforms such as i386.  The first two  ver?<br />sions  were  already  present  in  Linux 1.0 (albeit with different<br />names); the last was added in Linux 2.4.  Similar remarks apply for<br />fstat() and lstat().<br /><br />The  kernel-internal  versions  of the stat structure dealt with by<br />the different versions are, respectively:<br /><br />      __old_kernel_stat<br />             The original structure, with  rather  narrow  fields,<br />             and no padding.<br /><br />      stat   Larger  st_ino  field  and  padding  added to various<br />             parts of the structure to allow for future expansion.<br /><br />      stat64 Even larger st_ino field, larger  st_uid  and  st_gid<br />             fields to accommodate the Linux-2.4 expansion of UIDs<br />             and GIDs to  32  bits,  and  various  other  enlarged<br />             fields  and further padding in the structure.  (Vari?<br />             ous padding bytes were eventually consumed  in  Linux<br />             2.6,  with  the  advent  of  32-bit  device  IDs  and<br />             nanosecond components for the timestamp fields.)<br /><br />The glibc stat() wrapper function hides these details from applica?<br />tions, invoking the most recent version of the system call provided<br />by the kernel, and repacking the returned information  if  required<br />for old binaries.<br />-------------------------------------------------------------------<br /><br />So it's likely that glibc is tampering with stat instead of just<br />forwarding the syscall.<br /><br />You can actually check this by writing a small libc stat test and<br />using strace to trace syscalls:<br />-------------------------------------------------------------------<br />$ cat > stattest.c &lt;&lt; "EOF"<br />#include &lt;sys/stat.h><br /><br />int main()<br />{<br />    struct stat s;<br />    stat("/etc/hosts", &amp;s);<br />    return 0;<br />}<br />EOF<br /><br />$ gcc -m32 stattest.c<br />$ strace ./a.out<br />execve("./a.out", ["./a.out"], [/* 83 vars */]) = 0<br />[ Process PID=22487 runs in 32 bit mode. ]<br />... stuff we don't care about ...<br />stat64("/etc/hosts", {st_mode=S_IFREG|0644, st_size=1212, ...}) = 0<br />exit_group(0)                           = ?<br />+++ exited with 0 +++<br />-------------------------------------------------------------------<br /><br />Yep, as expected, the stat call is getting translated to stat64!<br /><br />So how do we fix this? By not trusting libc headers and digging<br />into the kernel headers (which I found by googling the kernel<br />struct names):<br />-------------------------------------------------------------------<br />$ printf "#include &lt;asm/stat.h>" \<br />  | gcc -m32 -E - | grep -A 30 "struct stat"<br />struct stat {<br /> unsigned long st_dev;<br /> unsigned long st_ino;<br /> unsigned short st_mode;<br /> unsigned short st_nlink;<br /> unsigned short st_uid;<br /> unsigned short st_gid;<br /> unsigned long st_rdev;<br /> unsigned long st_size;<br /> unsigned long st_blksize;<br /> unsigned long st_blocks;<br /> unsigned long st_atime;<br /> unsigned long st_atime_nsec;<br /> unsigned long st_mtime;<br /> unsigned long st_mtime_nsec;<br /> unsigned long st_ctime;<br /> unsigned long st_ctime_nsec;<br /> unsigned long __unused4;<br /> unsigned long __unused5;<br />};<br />-------------------------------------------------------------------<br /><br />That's a very different than what glibc headers were telling us!<br />There is no padding and st_dev is 4 bytes instead of 8, as well<br />as a lot of other fields having smaller sizes.<br /><br />What about the 64-bit version of it?<br />-------------------------------------------------------------------<br />$ printf "#include &lt;asm/stat.h>" \<br />  | gcc -E - | grep -A 30 "struct stat"<br />struct stat {<br /> __kernel_ulong_t st_dev;<br /> __kernel_ulong_t st_ino;<br /> __kernel_ulong_t st_nlink;<br /><br /> unsigned int st_mode;<br /> unsigned int st_uid;<br /> unsigned int st_gid;<br /> unsigned int __pad0;<br /> __kernel_ulong_t st_rdev;<br /> __kernel_long_t st_size;<br /> __kernel_long_t st_blksize;<br /> __kernel_long_t st_blocks;<br /><br /> __kernel_ulong_t st_atime;<br /> __kernel_ulong_t st_atime_nsec;<br /> __kernel_ulong_t st_mtime;<br /> __kernel_ulong_t st_mtime_nsec;<br /> __kernel_ulong_t st_ctime;<br /> __kernel_ulong_t st_ctime_nsec;<br /> __kernel_long_t __unused[3];<br />};<br />-------------------------------------------------------------------<br /><br />This one seems to have the correct layout, except that some of the<br />values are unsigned rather than signed.<br /><br />Here's our fixed stat struct:<br />-------------------------------------------------------------------<br />typedef uintptr dev_t;<br />typedef intptr syscall_slong_t;<br />typedef uintptr syscall_ulong_t;<br />typedef uintptr time_t;<br /><br />typedef struct<br />{<br />    time_t sec;<br />    syscall_ulong_t nsec;<br />}<br />timespec;<br /><br />typedef struct<br />{<br />    dev_t dev;<br />    uintptr ino;<br />#ifdef AMD64<br />    uintptr nlink;<br />    u32 mode;<br />    u32 uid;<br />    u32 gid;<br />    u32 __pad0;<br />#else<br />    u16 mode;<br />    u16 nlink;<br />    u16 uid;<br />    u16 gid;<br />#endif<br />    dev_t rdev;<br />    uintptr size;<br />    uintptr blksize;<br />    uintptr blocks;<br />    timespec atim;<br />    timespec mtim;<br />    timespec ctim;<br />#ifdef AMD64<br />    syscall_slong_t __unused[3];<br />#else<br />    u32 __unused4;<br />    u32 __unused5;<br />#endif<br />}<br />stat_info;<br />-------------------------------------------------------------------<br /><br />Now we can run it again and verify that the struct is properly<br />populated in both architectures (I added comments to show where<br />fields are, those aren't actually part of hexdump)<br />-------------------------------------------------------------------<br />$ ./stat | hexdump -C<br />00000000  12 08 00 00 00 00 00 00  50 59 0a 00 00 00 00 00<br />         |         dev           |          ino           |<br /><br />00000010  01 00 00 00 00 00 00 00  a4 81 00 00 00 00 00 00<br />         |        nlink          |    mode    |    uid    |<br /><br />00000020  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00<br />         |    gid    |  __pad0   |          rdev          |<br /><br />00000030  bc 04 00 00 00 00 00 00  00 10 00 00 00 00 00 00<br />         |          size         |        blksize         |<br /><br />00000040  08 00 00 00 00 00 00 00  24 b2 e9 57 00 00 00 00<br />         |         blocks        |        atim.sec        |<br /><br />00000050  d1 f4 e1 2f 00 00 00 00  e8 d8 5e 57 00 00 00 00<br />         |       atim.nsec       |        mtim.sec        |<br /><br />00000060  a0 3a b4 24 00 00 00 00  e8 d8 5e 57 00 00 00 00<br />         |       mtim.nsec       |        ctim.sec        |<br /><br />00000070  20 c8 0f 25 00 00 00 00  00 00 00 00 00 00 00 00<br />         |       ctim.nsec       |       __unused[0]      |<br /><br />00000080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00<br />         |      __unused[1]      |       __unused[2]      |<br /><br />00000090<br /><br />$ ./build.sh i386<br />$ ./stat | hexdump -C<br />00000000  12 08 00 00 50 59 0a 00  a4 81 01 00 00 00 00 00<br />          |    dev   |    ino    | mode |nlink| uid | gid |<br /><br />00000010  00 00 00 00 bc 04 00 00  00 10 00 00 08 00 00 00<br />          |   rdev   |   size    |   blksize  |   blocks  |<br /><br />00000020  24 b2 e9 57 d1 f4 e1 2f  e8 d8 5e 57 a0 3a b4 24<br />          | atim.sec | atim.nsec |  mtim.sec  | mtim.nsec |<br /><br />00000030  e8 d8 5e 57 20 c8 0f 25  00 00 00 00 00 00 00 00<br />          | ctim.sec | ctim.nsec | __unused4  | __unused5 |<br /><br />00000040<br />-------------------------------------------------------------------<br /><br />In short, try getting structs from kernel headers instead of libc.<br /><br />###################################################################<br />                      Legacy sockets on i386<br />###################################################################<br /><br />Another thing you should be aware of, is that some syscalls might<br />work entirely differently on i386 because of historical reasons.<br /><br />Socket syscalls are a perfect example. i386 doesn't have SYS_accept<br />and as far as I know the other socket syscalls are also not<br />guaranteed to exist.<br /><br />Instead, i386 multiplexes all socket syscalls through a single<br />syscall named "socketcall", which takes an additional param which<br />specifies which socket operation we want do to, (accept, connect,<br />etc...) followed by the usual syscall params that we find on amd64.<br /><br />Also, parameters for socketcall are passed through a void* array,<br />so the socketcall syscall just takes two parameters: the call<br />number and the pointer to the parameters array.<br /><br />Googling the socketcall numbers was a bit difficult, but I<br />eventually found them in linux/net.h.<br /><br />-------------------------------------------------------------------<br />$ printf "#include &lt;sys/syscall.h>\nblah SYS_accept" \<br />  | gcc -m32 -E - | grep blah<br />blah SYS_accept<br /><br />$ man socketcall<br />SYNOPSIS<br />int socketcall(int call, unsigned long *args);<br /><br />DESCRIPTION<br />socketcall()  is  a common kernel entry point for the socket system<br />calls.  call determines which  socket  function  to  invoke.   args<br />points to a block containing the actual arguments, which are passed<br />through to the appropriate call.<br /><br />User programs should call the appropriate functions by their  usual<br />names.   Only standard library implementors and kernel hackers need<br />to know about socketcall().<br /><br />$ printf "#include &lt;linux/net.h>\nblah SYS_SOCKET" \<br />  | gcc -m32 -E - | grep blah<br />blah 1<br /><br />$ printf "#include &lt;linux/net.h>\nblah SYS_CONNECT" \<br />  | gcc -m32 -E - | grep blah<br />blah 3<br />-------------------------------------------------------------------<br /><br />Here's an example socket application for i386 and amd64 that<br />connects to sdf.org's gopherspace (192.94.73.15:70) and dumps the<br />output for the root folder.<br /><br />I got the sockaddr_in struct from netinet/in.h and the socket<br />constants from sys/socket.h<br /><br />-------------------------------------------------------------------<br />$ cat amd64/syscalls.h <br />#define SYS_read    0<br />#define SYS_write   1<br />#define SYS_close   3<br />#define SYS_socket  41<br />#define SYS_connect 42<br />#define SYS_exit    60<br /><br />$ cat i386/syscalls.h <br />#define SYS_read       3<br />#define SYS_write      4<br />#define SYS_close      6<br />#define SYS_exit       1<br />#define SYS_socketcall 102<br /><br />$ cat socket.c<br />#define internal static<br /><br />void* syscall1(<br />    uintptr number,<br />    void* arg1<br />);<br /><br />void* syscall2(<br />    uintptr number,<br />    void* arg1,<br />    void* arg2<br />);<br /><br />void* syscall3(<br />    uintptr number,<br />    void* arg1,<br />    void* arg2,<br />    void* arg3<br />);<br /><br />/* ------------------------------------------------------------- */<br /><br />#define stdout 1<br />#define stderr 2<br /><br />internal<br />void close(int fd) {<br />    syscall1(SYS_close, (void*)(intptr)fd);<br />}<br /><br />internal<br />intptr write(int fd, void const* data, uintptr nbytes)<br />{<br />    return (uintptr)<br />        syscall3(<br />            SYS_write,<br />            (void*)(intptr)fd,<br />            (void*)data,<br />            (void*)nbytes<br />        );<br />}<br /><br />internal<br />intptr read(int fd, void* data, intptr nbytes)<br />{<br />    return (intptr)<br />        syscall3(<br />            SYS_read,<br />            (void*)(intptr)fd,<br />            data,<br />            (void*)nbytes<br />        );<br />}<br /><br />#define AF_INET 2<br />#define SOCK_STREAM 1<br />#define IPPROTO_TCP 6<br /><br />typedef struct<br />{<br />    u16 family;<br />    u16 port; /* NOTE: this is big endian!!!!!!! use flip16u */<br />    u32 addr; /* this is also big endian */<br />    u8  zero[8];<br />}<br />sockaddr_in;<br /><br />#ifdef SYS_socketcall<br />/* i386 multiplexes socket calls through socketcall */<br />#define SYS_SOCKET      1<br />#define SYS_CONNECT     3<br /><br />internal<br />int socketcall(u32 call, void* args)<br />{<br />    return (int)(intptr)<br />        syscall2(<br />            SYS_socketcall,<br />            (void*)(intptr)call,<br />            args<br />        );<br />}<br />#endif<br /><br />internal<br />int socket(u16 family, i32 type, i32 protocol)<br />{<br />#ifndef SYS_socketcall<br />    return (int)(intptr)<br />        syscall3(<br />            SYS_socket,<br />            (void*)(intptr)family,<br />            (void*)(intptr)type,<br />            (void*)(intptr)protocol<br />        );<br />#else<br />    void* args[3];<br />    args[0] = (void*)(intptr)family;<br />    args[1] = (void*)(intptr)type;<br />    args[2] = (void*)(intptr)protocol;<br /><br />    return socketcall(SYS_SOCKET, args);<br />#endif<br />}<br /><br />internal<br />int connect(int sockfd, sockaddr_in const* addr)<br />{<br />#ifndef SYS_socketcall<br />    return (int)(intptr)<br />        syscall3(<br />            SYS_connect,<br />            (void*)(intptr)sockfd,<br />            (void*)addr,<br />            (void*)sizeof(sockaddr_in)<br />        );<br />#else<br />    void* args[3];<br />    args[0] = (void*)(intptr)sockfd;<br />    args[1] = (void*)addr;<br />    args[2] = (void*)sizeof(sockaddr_in);<br /><br />    return socketcall(SYS_CONNECT, args);<br />#endif<br />}<br /><br />/* ------------------------------------------------------------- */<br /><br />internal<br />intptr strlen(char const* str)<br />{<br />    char const* p;<br />    for(p = str; *p; ++p);<br />    return p - str;<br />}<br /><br />internal<br />intptr fputs(int fd, char const* str) {<br />    return write(fd, str, strlen(str));<br />}<br /><br />/* reverses byte order of a 16-bit integer (0x1234 -> 0x3412) */<br />internal<br />u16 flip16u(u16 v) {<br />    return (v &lt;&lt; 8) | (v >> 8);<br />}<br /><br />/* ------------------------------------------------------------- */<br /><br />#define BUFSIZE 512<br /><br />internal<br />int socket_run(int argc, char const* argv[])<br />{<br />    int res = 0; /* return code */<br /><br />    int fd;<br />    u8 ip_raw[] = { 192, 94, 73, 15 }; /* ip in big endian order */<br />    u32* pip = (u32*)ip_raw; /* pointer to ip as a 32-bit int */<br />    sockaddr_in a;<br /><br />    intptr n;<br />    u8 buf[BUFSIZE];<br /><br />    /* set up sockaddr struct with desired ip &amp; port */<br />    a.family = AF_INET;<br />    a.port = flip16u(70);<br />    a.addr = *pip;<br /><br />    for (n = 0; n &lt; 8; ++n) {<br />        a.zero[n] = 0;<br />    }<br /><br />    /* create a new socket */<br />    fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);<br />    if (fd &lt; 0) {<br />        fputs(stderr, "socket failed\n");<br />        return 1;<br />    }<br /><br />    /* connect to sdf.org */<br />    if (connect(fd, &amp;a) &lt; 0)<br />    {<br />        fputs(stderr, "connect failed\n");<br />        res = 1;<br />        goto cleanup;<br />    }<br /><br />    /* request folder / */<br />    fputs(fd, "/\r\n");<br /><br />    /* read chunks of BUFSIZE bytes and relay them to stdout until<br />       there is nothing left to read or the socket errors out */<br />    while (1)<br />    {<br />        n = read(fd, buf, BUFSIZE);<br />        if (n &lt;= 0) {<br />            break;<br />        }<br /><br />        if (write(stdout, buf, n) != n)<br />        {<br />            fputs(stderr, "write failed\n");<br />            res = 1;<br />            break;<br />        }<br />    }<br /><br />    if (n &lt; 0) {<br />        fputs(stderr, "read failed\n");<br />        res = 1;<br />    }<br /><br />cleanup:<br />    /* make sure to not leave a dangling socket file descriptor */<br />    close(fd);<br /><br />    return res;<br />}<br />-------------------------------------------------------------------<br /><br />And as you can see, we are running flawlessly on both architectures<br />-------------------------------------------------------------------<br />$ ./build.sh &amp;&amp; ./socket<br />iWelcome to the SDF Public Access UNIX System .. est. 1987...<br /><br />$ ./build.sh i386 &amp;&amp; ./socket<br />iWelcome to the SDF Public Access UNIX System .. est. 1987...<br />-------------------------------------------------------------------<br /><br />###################################################################<br />                             Conclusion<br />###################################################################<br />I hope this guide got you interested in understanding what happens<br />at the lowest level and knowing your programming language and OS<br />beyond the standard library! Have fun! I will add more tricks if<br />I come up with new ones.<br /></body></html>