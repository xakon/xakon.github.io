Snippets
--------

Long or Many Parameters
~~~~~~~~~~~~~~~~~~~~~~~

A nice technique I recently discovered.  It reminds a lot the way we split in
Python long parameter lists in function calls.  The trick is to use the `where`
clause and very close to the function call, define the parameters as separate
bindings:

[source,haskell]
----
sendEmail myEmail
   where to   = "levi@startup.com"
         from = "chris@website.org"
	 body = "Hi!"
	 name = "Levi"
	 myEmail = Email from to body name
----

Actually, even the reverse order might read more like in Python:

[source,haskell]
----
sendEmail myEmail
   where myEmail = Email from to body name
         to      = "levi@startup.com"
         from    = "chris@website.org"
	 body    = "Hi!"
	 name    = "Levi"
----


Elements of list as pairs
~~~~~~~~~~~~~~~~~~~~~~~~~

A rather useful function that is often needed in various Code Advent puzzles,
is the `pairs`.  Extracted from the book, "Programming in Haskell".

[source,haskell]
----
pairs xs = zip xs (tail xs)
----


Sieve of Eratosthenes
~~~~~~~~~~~~~~~~~~~~~

Since a lot of discussions are carried about the famous implementation of the
https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes[Sieve of Eratosthenes]
in Haskell, let me add the basic definition here, in order to easily reference
it:

[source,haskell]
----
sieve (p:xs) = p : sieve [x | x <- xs, x `mod` p > 0]
primes = sieve [2..]
----

It is easier to understand how this works in Haskell, if we actually follow the
evaluation of the functions.  This can easier be shown in the article:
https://hookrace.net/blog/a-taste-of-haskell/[A Taste of Haskell].

For completeness, let's include the definition of `primes` in simple terms,
albeit not as performant as the above.  I omit the types for the following
functions, for a more compact format.

[source,haskell]
----
factors n = [x | x <- [1..n], n `mod` x == 0]
prime n = factors n == [1, n]
primes n = [x | x <- [2..n], prime x]
----

The functions were copied from the book, "Programming in Haskell".


Sequencing Actions
~~~~~~~~~~~~~~~~~~

Erik Meijer once joked that Haskell is a very imperative language, as it allows
one to write programs in steps, sequences, and in style that reminds the other
imperative languages.

In the book "Programming in Haskell, 2/e" there is a nice snippet of executing
many 'Actions' in sequence, but in a concise style, avoiding the 'do-notation':

[source,haskell]
----
seqn []         = return []
seqn (act:acts) = do x <- act
                     xs <- seqn acts
		     return (x:xs)
----


Quick Sort
~~~~~~~~~~

The classic example of presenting the benefits of Haskell, as a concise and
effective language.

This snippet was extracted from the book "Programming in Haskell, 2/e".

[source,haskell]
----
qsort []     = []
qsort (x:xs) = qsort smaller ++ [x] ++ qsort larger
               where
	         smaller = [a | a <- xs, a <= x]
		 larger  = [b | b <- xs, b > x]
----


////
# vim: set ft=asciidoc:
////
